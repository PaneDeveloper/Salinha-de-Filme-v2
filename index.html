<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sala de Filme :3</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>

<style>
  body {
    font-family: 'Inter', sans-serif;
    background-color: #111827;
    color: #e5e7eb;
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
  }
  #chatMessages {
    max-height: 300px;
    overflow-y: auto;
    padding: 0.5rem;
    background: #1f2937;
    border-radius: 0.5rem;
    word-wrap: break-word; /* Garante que mensagens longas quebrem a linha */
  }
  #chatMessages div {
    margin-bottom: 0.5rem;
  }
  .system-msg {
    text-align: center;
    font-style: italic;
    color: #9ca3af;
  }
</style>
</head>
<body>

<div id="container" style="max-width: 480px; width: 100%;">

  <div id="menu">
    <h1 class="text-3xl font-bold mb-2">Movie Room</h1>
    <p class="mb-6">Crie uma sala para você(s) assistir(rem) :3</p>

    <button id="btnCreateRoom" class="w-full py-3 mb-4 bg-indigo-600 rounded text-white font-bold">Criar Sala</button>

    <div class="flex gap-2 mb-4">
      <input id="roomInput" placeholder="CÓDIGO DA SALA" maxlength="4" class="flex-grow p-3 rounded bg-gray-700 text-white uppercase" />
      <button id="btnJoinRoom" class="py-3 px-5 bg-gray-600 rounded text-white font-bold">Entrar</button>
    </div>

    <p id="authStatus" class="text-gray-400 text-sm">Autenticando...</p>
  </div>

  <div id="app" class="hidden flex flex-col">
    <div class="flex justify-between items-center mb-4">
      <h2 class="text-xl font-semibold">Sala: <span id="roomCodeDisplay" class="text-indigo-400"></span></h2>
      <button id="btnLeaveRoom" class="bg-red-600 text-white px-3 py-1 rounded">Sair</button>
    </div>

    <video id="localPreviewVideo" autoplay playsinline muted class="w-full h-40 bg-gray-900 rounded mb-2 hidden"></video>

    <video id="remoteVideo" autoplay playsinline controls class="w-full h-64 bg-black rounded mb-4"></video>

    <div id="videoPlaceholder" class="text-center text-gray-400 mb-4">
      <p>Esperando alguém compartilhar a tela...</p>
      <button id="btnStartShare" class="mt-3 bg-indigo-600 text-white px-4 py-2 rounded font-bold">Compartilhar Tela</button>
    </div>

    <div id="chatMessages" class="mb-3"></div>

    <div class="flex gap-2">
      <input id="chatInput" placeholder="Sua mensagem Aqui =D" class="flex-grow p-2 rounded bg-gray-700 text-white" />
      <button id="sendChatBtn" class="bg-indigo-600 text-white px-4 py-2 rounded font-bold">Enviar</button>
    </div>
  </div>

</div>

<script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-firestore.js"></script>

<script>
  // === CONFIGURAÇÃO FIREBASE ===
  //
  // SUBSTITUA ESTE BLOCO COM A SUA firebaseConfig!
  //
  const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
    apiKey: "AIzaSyADv0rYIOrPpysbl5i4UkddDK1EKyGY06c",
    authDomain: "salinha-de-filme-v2.firebaseapp.com",
    projectId: "salinha-de-filme-v2",
    storageBucket: "salinha-de-filme-v2.firebasestorage.app",
    messagingSenderId: "356504534538",
    appId: "1:356504534538:web:7c5864a0fc2a93a24229f3"
  };
  const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
  const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

  const appFirebase = firebase.initializeApp(firebaseConfig);
  const auth = appFirebase.auth();
  const db = appFirebase.firestore();
  
  // Pequena alteração para garantir que o arquivo seja atualizado.
  console.log("Arquivo de código atualizado.");


  // Elementos DOM
  const btnCreateRoom = document.getElementById('btnCreateRoom');
  const btnJoinRoom = document.getElementById('btnJoinRoom');
  const roomInput = document.getElementById('roomInput');
  const authStatus = document.getElementById('authStatus');

  const menu = document.getElementById('menu');
  const app = document.getElementById('app');
  const roomCodeDisplay = document.getElementById('roomCodeDisplay');
  const btnLeaveRoom = document.getElementById('btnLeaveRoom');
  const localPreviewVideo = document.getElementById('localPreviewVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const videoPlaceholder = document.getElementById('videoPlaceholder');
  const btnStartShare = document.getElementById('btnStartShare');
  const chatMessages = document.getElementById('chatMessages');
  const chatInput = document.getElementById('chatInput');
  const sendChatBtn = document.getElementById('sendChatBtn');

  // Variáveis de estado
  let userId = null;
  let currentRoomId = null;
  let peer = null;
  let localStream = null;
  let isRoomCreator = false; // Flag para identificar se o usuário é o criador da sala

  // Listeners de Firestore para desinscrição
  let unsubscribeRoom = null;
  let unsubscribeChat = null;
  let unsubscribeCandidates = null;


  /**
   * Exibe uma mensagem no painel de chat.
   * @param {string} text - O texto da mensagem.
   * @param {string|null} sender - O remetente da mensagem (ex: 'Você', 'Amigo'). Nulo para mensagens do sistema.
   * @param {boolean} isSystem - Verdadeiro se for uma mensagem do sistema.
   */
  function showMessage(text, sender = null, isSystem = false) {
    const div = document.createElement('div');
    if (isSystem) {
      div.textContent = text;
      div.classList.add('system-msg');
    } else {
      div.innerHTML = `<strong>${sender}:</strong> ${text}`;
    }
    chatMessages.appendChild(div);
    chatMessages.scrollTop = chatMessages.scrollHeight; // Rola para a mensagem mais recente
  }

  /**
   * Exibe um modal customizado no lugar de 'alert'.
   * @param {string} message - A mensagem a ser exibida.
   */
  function showModal(message) {
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = '#1f2937';
    modal.style.color = '#e5e7eb';
    modal.style.padding = '1.5rem';
    modal.style.borderRadius = '0.5rem';
    modal.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
    modal.style.zIndex = '1000';
    modal.style.width = '300px';
    modal.style.textAlign = 'center';

    const text = document.createElement('p');
    text.textContent = message;
    text.style.marginBottom = '1rem';
    modal.appendChild(text);

    const button = document.createElement('button');
    button.textContent = 'OK';
    button.style.backgroundColor = '#4f46e5';
    button.style.color = 'white';
    button.style.padding = '0.5rem 1rem';
    button.style.borderRadius = '0.25rem';
    button.style.fontWeight = 'bold';
    button.onclick = () => document.body.removeChild(modal);
    modal.appendChild(button);

    document.body.appendChild(modal);
  }

  // Listener de estado de autenticação do Firebase.
  auth.onAuthStateChanged(user => {
    if (user) {
      userId = user.uid;
      authStatus.textContent = 'Conectado com sucesso!';
      btnCreateRoom.disabled = false;
      btnJoinRoom.disabled = false;
      console.log("Usuário autenticado com ID:", userId);
    } else {
      userId = null;
      authStatus.textContent = 'Autenticando...';
      btnCreateRoom.disabled = true;
      btnJoinRoom.disabled = true;
      if (!auth.currentUser) {
        if (initialAuthToken) {
          auth.signInWithCustomToken(initialAuthToken).catch(err => {
            authStatus.textContent = 'Não foi possível conectar aos serviços: ' + err.message;
            console.error("Erro na autenticação com token customizado:", err);
          });
        } else {
          auth.signInAnonymously().catch(err => {
            authStatus.textContent = 'Não foi possível conectar aos serviços: ' + err.message;
            console.error("Erro na autenticação anônima:", err);
          });
        }
      }
    }
  });


  /**
   * Gera um código de sala aleatório de 4 letras maiúsculas.
   * @returns {string} O código da sala.
   */
  function generateRoomCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let code = '';
    for(let i=0; i<4; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }
  
  /**
   * Retorna a referência correta para a coleção 'movie-rooms' no Firestore.
   * @param {string} roomId - O ID da sala.
   * @returns {firebase.firestore.DocumentReference} A referência do documento da sala.
   */
  function getRoomRef(roomId) {
    return db.collection('artifacts').doc(appId).collection('public').doc('data').collection('movie-rooms').doc(roomId);
  }


  // Evento de clique para o botão "Create New Room"
  btnCreateRoom.onclick = async () => {
    if (!userId) {
      showModal('Autenticando... Espere um pouco :3.');
      return;
    }

    btnCreateRoom.disabled = true;
    btnCreateRoom.textContent = 'Criando...';

    currentRoomId = generateRoomCode();
    roomCodeDisplay.textContent = currentRoomId;
    isRoomCreator = true; // Define o usuário como criador da sala

    const roomRef = getRoomRef(currentRoomId);
    const callerCandidates = roomRef.collection('callerCandidates');

    // A lógica de peer.on('signal') e peer.on('negotiated') foi melhorada para
    // tratar a re-negociação de stream, corrigindo o erro de 'm-lines'.
    peer = new SimplePeer({ initiator: true, trickle: true });

    peer.on('signal', async data => {
      if (data.type === 'offer') {
        try {
          await roomRef.set({
            offer: data,
            creatorId: userId,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          }, { merge: true });
        } catch (e) {
          // Adiciona um log de erro mais específico do Firestore
          console.error("ERRO FIREBASE: Falha ao salvar a oferta da sala. Verifique suas regras de segurança.", e);
          showModal("Erro ao criar a sala. Tente novamente.");
          hangUp();
        }
      } else if (data.candidate) {
        await callerCandidates.add(data);
      }
    });

    // Listener para o evento 'negotiate', que ocorre quando o stream é adicionado/removido.
    // Isso força o host a enviar um novo 'offer' para o cliente.
    peer.on('negotiated', () => {
      console.log('Evento de re-negociação acionado.');
      if (peer.initiator) {
        peer.signal(peer._pc.localDescription);
      }
    });

    unsubscribeRoom = roomRef.onSnapshot(snapshot => {
      const data = snapshot.data();
      if (data && data.answer) {
        if (peer && peer.initiator && data.answer.type === 'answer') {
          peer.signal(data.answer);
        }
      }
    }, error => {
      console.error("Erro ao ouvir o documento da sala:", error);
      showModal("Erro ao carregar dados da sala.");
    });

    const calleeCandidates = roomRef.collection('calleeCandidates');
    unsubscribeCandidates = calleeCandidates.onSnapshot(snapshot => {
      snapshot.docChanges().forEach(change => {
        if (change.type === 'added') {
          peer.signal(change.doc.data());
        }
      });
    }, error => {
      console.error("Erro ao ouvir os candidatos do callee:", error);
      showModal("Erro na comunicação de rede.");
    });

    peer.on('connect', () => {
      showMessage('Amigo conectado!', null, true);
      console.log('WebRTC Peer Conectado!');
    });

    peer.on('stream', stream => {
      console.log('Recebido stream remoto pelo host:', stream);
      videoPlaceholder.style.display = 'none';
      remoteVideo.srcObject = stream;
      if (remoteVideo.paused) {
        remoteVideo.play().catch(e => console.error("Erro ao tentar reproduzir vídeo remoto no host:", e));
      }
    });

    peer.on('close', () => {
      showMessage('Amigo desconectado.', null, true);
      console.log('WebRTC Peer Desconectado.');
      hangUp();
    });

    peer.on('error', err => {
      showModal('Erro na conexão: ' + err.message);
      console.error("Erro SimplePeer:", err);
      hangUp();
    });

    menu.style.display = 'none';
    app.style.display = 'flex';
    setupChatListener();

    btnCreateRoom.textContent = 'Create New Room';
  };

  // Evento de clique para o botão "Entrar" na sala
  btnJoinRoom.onclick = async () => {
    if (!userId) {
      showModal('Autenticando... Por favor aguarde.');
      return;
    }

    const code = roomInput.value.trim().toUpperCase();
    if (!code || code.length !== 4) {
      showModal('Por favor, insira um código válido de 4 letras.');
      return;
    }

    btnJoinRoom.disabled = true;
    btnJoinRoom.textContent = 'Entrando...';

    currentRoomId = code;
    roomCodeDisplay.textContent = currentRoomId;
    isRoomCreator = false; // Define o usuário como não criador da sala

    try {
      const roomRef = getRoomRef(currentRoomId);
      const roomSnapshot = await roomRef.get();

      if (!roomSnapshot.exists) {
        showModal(`A sala "${currentRoomId}" não foi encontrada.`);
        btnJoinRoom.disabled = false;
        btnJoinRoom.textContent = 'Entrar';
        return;
      }

      const roomData = roomSnapshot.data();

      peer = new SimplePeer({ initiator: false, trickle: true });
      peer.signal(roomData.offer);

      peer.on('signal', async data => {
        if (data.type === 'answer') {
          await roomRef.update({ answer: data });
        } else if (data.candidate) {
          const calleeCandidates = roomRef.collection('calleeCandidates');
          await calleeCandidates.add(data);
        }
      });
      
      // Listener para o evento 'negotiate', garantindo que o cliente sempre
      // processe o 'offer' re-negociado pelo host.
      peer.on('negotiated', () => {
        console.log('Evento de re-negociação acionado no cliente.');
      });


      const callerCandidates = roomRef.collection('callerCandidates');
      unsubscribeCandidates = callerCandidates.onSnapshot(snapshot => {
        snapshot.docChanges().forEach(change => {
          if (change.type === 'added') {
            peer.signal(change.doc.data());
          }
        });
      }, error => {
      console.error("Erro ao ouvir os candidatos do caller:", error);
      showModal("Erro na comunicação de rede.");
    });

      peer.on('connect', () => {
        showMessage('Amigo conectado!', null, true);
        console.log('WebRTC Peer Conectado!');
      });

      peer.on('stream', stream => {
        console.log('Recebido stream remoto pelo cliente:', stream);
        videoPlaceholder.style.display = 'none';
        remoteVideo.srcObject = stream;
        if (remoteVideo.paused) {
          remoteVideo.play().catch(e => console.error("Erro ao tentar reproduzir vídeo remoto no cliente:", e));
        }
      });

      peer.on('close', () => {
        showMessage('Amigo desconectado.', null, true);
        console.log('WebRTC Peer Desconectado.');
        hangUp();
      });

      peer.on('error', err => {
        showModal('Erro na conexão: ' + err.message);
        console.error("Erro SimplePeer:", err);
        hangUp();
      });

      menu.style.display = 'none';
      app.style.display = 'flex';
      setupChatListener();

      btnJoinRoom.disabled = false;
      btnJoinRoom.textContent = 'Entrar';

    } catch (e) {
      showModal('Ocorreu um erro inesperado ao tentar entrar na sala.');
      console.error('Erro ao entrar na sala:', e);
      hangUp();
    }
  };

  // Evento de clique para o botão "Compartilhar Tela"
  btnStartShare.onclick = async () => {
    try {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        console.log('Stream local existente removido.');
      }

      // === AQUI ESTÁ A FUNCIONALIDADE QUE VOCÊ QUER ===
      // Usando getDisplayMedia para compartilhar a tela e o áudio.
      localStream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true
      });
      
      console.log('Stream local (tela) obtido:', localStream);

      if (peer) {
        localPreviewVideo.srcObject = localStream;
        localPreviewVideo.style.display = 'block';
        videoPlaceholder.style.display = 'none';

        peer.addStream(localStream);
        console.log('Stream local (tela) adicionado ao peer para transmissão.');

      } else {
        console.warn('Peer não inicializado. Não foi possível adicionar o stream de tela.');
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        showModal('Por favor, crie ou entre em uma sala antes de compartilhar a tela.');
        return;
      }

      localStream.getVideoTracks()[0].onended = () => {
        showMessage('Compartilhamento de tela encerrado.', null, true);
        console.log('Compartilhamento de tela encerrado pelo usuário.');
        btnStartShare.disabled = false;
        btnStartShare.textContent = 'Compartilhar Tela';

        if (peer && localStream) {
          peer.removeStream(localStream);
        }

        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }

        remoteVideo.srcObject = null;
        videoPlaceholder.style.display = 'block'; // Mostra o placeholder de vídeo novamente
        localPreviewVideo.style.display = 'none';
      };

      btnStartShare.disabled = true;
      btnStartShare.textContent = 'Compartilhando...';

    } catch (err) {
      console.error("Erro ao compartilhar a tela:", err);
      if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
        showModal('Permissão para compartilhar a tela negada. Por favor, verifique as configurações de privacidade do seu navegador ou execute em um ambiente com permissão.');
      } else {
        showModal('Ocorreu um erro inesperado ao tentar compartilhar a tela: ' + err.message);
      }
    }
  };


  // Evento de clique para o botão "Enviar" do chat
  sendChatBtn.onclick = async () => {
    const text = chatInput.value.trim();
    if (!text || !currentRoomId) return;

    showMessage(text, 'Você');
    chatInput.value = '';

    try {
      const chatRef = getRoomRef(currentRoomId).collection('chat');
      await chatRef.add({
        text,
        senderId: userId,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });
    } catch (e) {
      showModal('Falha ao enviar a mensagem.');
      console.error("Erro ao enviar mensagem de chat:", e);
    }
  };

  // Evento de teclado para enviar mensagem do chat com Enter
  chatInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendChatBtn.click();
    }
  });

  /**
   * Configura o listener em tempo real para as mensagens do chat no Firestore.
   */
  function setupChatListener() {
    if (unsubscribeChat) unsubscribeChat();

    const chatRef = getRoomRef(currentRoomId).collection('chat').orderBy('timestamp');
    unsubscribeChat = chatRef.onSnapshot(snapshot => {
      snapshot.docChanges().forEach(change => {
        if (change.type === 'added') {
          const data = change.doc.data();
          if (data.senderId !== userId) {
            showMessage(data.text, 'Amigo');
          }
        }
      });
    }, error => {
      console.error("Erro ao ouvir o chat:", error);
      showModal("Não foi possível carregar as mensagens do chat.");
    });
  }


  // Evento de clique para o botão "Sair da Sala"
  btnLeaveRoom.onclick = () => {
    hangUp(true); // Indica que a saída foi iniciada pelo usuário
  };

  /**
   * Função para encerrar a conexão WebRTC, parar streams e resetar o estado da UI e variáveis.
   * @param {boolean} userInitiated - Verdadeiro se a função foi chamada por uma ação explícita do usuário (ex: botão Sair).
   */
  async function hangUp(userInitiated = false) {
    if (peer) {
      peer.destroy();
      peer = null;
    }
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }
    if (unsubscribeRoom) {
      unsubscribeRoom();
      unsubscribeRoom = null;
    }
    if (unsubscribeChat) {
      unsubscribeChat();
      unsubscribeChat = null;
    }
    if (unsubscribeCandidates) {
      unsubscribeCandidates();
      unsubscribeCandidates = null;
    }

    if (isRoomCreator && currentRoomId && userInitiated) {
      try {
        const roomRef = getRoomRef(currentRoomId);
        await roomRef.delete();
        console.log(`Sala ${currentRoomId} apagada pelo criador.`);
      } catch (error) {
        console.error("Erro ao apagar a sala:", error);
      }
    }

    currentRoomId = null;
    remoteVideo.srcObject = null;
    localPreviewVideo.srcObject = null;
    chatMessages.innerHTML = '';
    chatInput.value = '';
    roomInput.value = '';
    isRoomCreator = false;

    menu.style.display = 'block';
    app.style.display = 'none';

    btnCreateRoom.disabled = false;
    btnCreateRoom.textContent = 'Create New Room';
    btnJoinRoom.disabled = false;
    btnJoinRoom.textContent = 'Entrar';
    btnStartShare.disabled = false;
    btnStartShare.textContent = 'Compartilhar Tela';
    videoPlaceholder.style.display = 'block';
    localPreviewVideo.style.display = 'none';
  }

  // Adiciona um listener para o evento beforeunload para o caso de atualizar a página ou fechar a aba
  window.addEventListener('beforeunload', () => {
    if (isRoomCreator && currentRoomId) {
      getRoomRef(currentRoomId).delete()
        .then(() => console.log("Sala tentando ser apagada ao descarregar a página (criador)."))
        .catch(e => console.error("Erro ao tentar apagar sala ao descarregar (criador):", e));
    }
  });


  // Inicialização da aplicação
  window.onload = () => {
    btnCreateRoom.disabled = true;
    btnJoinRoom.disabled = true;
  };
</script>

</body>
</html>
